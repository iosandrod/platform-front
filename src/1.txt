<a-config-provider :getPopupContainer="getPopupContainer">
    <ThemeProvider is-root v-bind="themeConfig" :apply-style="false">
      <stepin-view
        system-name="Stepin"
        logo-src="@/assets/vite.svg"
        :class="`${contentClass}`"
        :user="user"
        :navMode="navigation"
        :useTabs="useTabs"
        :themeList="themeList"
        v-model:show-setting="showSetting"
        v-model:theme="theme"
        @themeSelect="configTheme"
      >
      </stepin-view>
    </ThemeProvider>
  </a-config-provider>
  <login-modal :unless="['/login']" />



  import { reactive, ref } from 'vue';
import { useRouter } from 'vue-router';
import { useAccountStore, useMenuStore, useSettingStore, storeToRefs } from '@/store';
import avatar from '@/assets/avatar.png';
import { PageFooter, HeaderActions } from '@/components/layout';
import Setting from './components/setting';
import { LoginModal } from '@/pages/login';
import { configTheme, themeList } from '@/theme';
import { ThemeProvider } from 'stepin';
import { computed } from 'vue';

const { logout, profile } = useAccountStore();

// 获取个人信息
profile().then((response) => {
  const { account } = response;
  user.name = account.username;
  // user.avatar = account.avatar;
});

const showSetting = ref(false);
const router = useRouter();

useMenuStore().getMenuList();

const { navigation, useTabs, theme, contentClass } = storeToRefs(useSettingStore());
const themeConfig = computed(() => themeList.find((item) => item.key === theme.value)?.config ?? {});

const user = reactive({
  name: 'admin',
  avatar: avatar,
  menuList: [
    { title: '个人中心', key: 'personal', icon: 'UserOutlined', onClick: () => router.push('/profile') },
    { title: '设置', key: 'setting', icon: 'SettingOutlined', onClick: () => (showSetting.value = true) },
    { type: 'divider' },
    {
      title: '退出登录',
      key: 'logout',
      icon: 'LogoutOutlined',
      onClick: () => logout().then(() => router.push('/login')),
    },
  ],
});

function getPopupContainer() {
  return document.querySelector('.stepin-layout');
}



 "dayjs": "^1.11.7",
    "element-plus": "^2.2.28",
    "everright-filter": "^1.1.1", 
    "jss": "^10.9.2",
    "jss-preset-default": "^10.9.2",
    "lodash": "^4.17.21",
    "nanoid": "^4.0.0",
    "nzh": "^1.0.8",
    "signature_pad": "^4.1.4",
    "vant": "^4.0.8",
    "vite-svg-loader": "^4.0.0",
    "vuedraggable": "^4.1.0"
     "@vant/area-data": "^1.4.0",
    "@vant/touch-emulator": "^1.4.0",
    "@vue/shared": "^3.2.45",
    "@vuelidate/core": "^2.0.0",
    "@vuelidate/validators": "^2.0.0",
    "async": "^3.2.4",
    "axios": "^1.2.2",
    "canvas": "^2.11.2"


    class ControlInsertion {
    sortable:any
    constructor(sortable) {
      this.sortable = sortable;
    }
    dragStart(e) {
      // 处理拖拽开始逻辑
    }

    drop(e) {
      if (!prevEl || !e.activeSortable) {
        return false;
      }
      const isBlock = _.get(e, 'activeSortable.options.dataSource', false) === 'block';
      const { dragEl, target } = e;
      const oldEl = getDragElement(dragEl);
      const newElement = ER.wrapElement(_.cloneDeep(oldEl), inserRowIndex !== '', true, isBlock);

      if (!isBlock && oldEl.context) {
        oldEl.context.delete();
      }

      if (inserRowIndex !== '') {
        let store = [];
        if (prevSortable.options.parent.type === 'subform') {
          store = prevSortable.options.parent.list[0];
        } else {
          store = Array.isArray(prevSortable.options.parent)
            ? prevSortable.options.parent
            : prevSortable.options.parent.list;
        }
        store.splice(inserRowIndex, 0, newElement);
        utils.addContext(store[inserRowIndex], prevSortable.options.parent);
      }

      if (inserColIndex !== '') {
        const { list } = prevSortable.el.__draggable_component__;
        list.splice(inserColIndex, 0, newElement);
        //@ts-ignore
        utils.addContext(newElement, prevSortable.options.parent[sortableUtils.index(prevSortable.el.parentNode)]);
      }

      if (inserColIndex !== '' || inserRowIndex !== '') {
        utils.deepTraversal(newElement, (node) => {
          if (utils.checkIsField(node)) {
            ER.addField(node);
          }
        });
        nextTick(() => {
          ER.setSelection(newElement);
        });
      }
      this.resetStates();
    }

    dragOver(e) {
      e.cancel();
      this.resetStates();
      const {
        activeSortable: {
          constructor: {
            utils: SortableUtils
          },
          options: {
            dataSource
          },
          el: {
            __draggable_component__: {
              list
            }
          } 
        }, 
        activeSortable,
        target,
        originalEvent,
        dragEl,
        sortable
      } = e;

      if (sortable.options.dataSource === 'block' || target.dataset.layoutType === 'grid') {
        return false;
      }

      const dragNode = getDragElement(dragEl);
      const targetNode = getDragElement(target);
      if ((!utils.checkIsField(dragNode) || dragNode.type === 'subform') && utils.checkIsInSubform(targetNode)) {
        return false;
      }
      if (target.dataset.layoutType === 'subform' && (!utils.checkIsField(dragNode) || dragNode.type === 'subform')) {
        return false;
      }

      originalEvent.stopPropagation && originalEvent.stopPropagation();
      //@ts-ignore
      let newTarget = SortableUtils.closest(target, this.sortable.options.draggable, sortable.el);
      if (dragEl.contains(newTarget)) {
        return false;
      }

      if (/^(grid-col|tabs-col|td|collapse-col|root|inline|subform)$/.test(target.dataset.layoutType)) {
        newTarget = target;
        const state = newTarget.__draggable_component__ || newTarget.children[0].__draggable_component__;
        if (!state.list.length) {
          prevEl = target.dataset.layoutType === 'root' ? target : (newTarget.__draggable_component__ ? newTarget.children[0] : newTarget.parentNode);
          prevSortable = state._sortable;
          inserRowIndex = 0;
          setBorder(prevEl, 'drag-line-top');
        } else {
          if (/^(root|grid-col)$/.test(target.dataset.layoutType)) {
            prevEl = lastChild(sortable.el);
            if (prevEl === dragEl.parentNode.parentNode && list.length === 1) {
              prevEl = '';
              return false;
            }
            setBorder(prevEl, 'drag-line-bottom');
            inserRowIndex = sortable.el.children.length;
            prevSortable = state._sortable;
          }
          if (target.dataset.layoutType === 'inline' && !disableBothSides(ER)) {

            prevEl = lastChild(sortable.el);
            if (prevEl.contains(dragEl) && list.length === 1) {
              prevEl = '';
              return false;
            }
            inserColIndex = sortable.el.children.length;
            prevSortable = state._sortable;
            setBorder(prevEl, 'drag-line-right');
          }
        }
      } else {
        this.setStates(newTarget, e, ER);
      }
    }

    resetStates() {
      prevEl = null;
      prevSortable = null;
      inserRowIndex = '';
      inserColIndex = '';
    }

    setStates(newTarget, e, ER) {
      // 处理插入状态的逻辑
    }
  }
  return Object.assign(ControlInsertion, {
    pluginName: 'ControlInsertion',
    initializeByDefault: true
  });












  function ControlInsertion (sortable) {
  }
  ControlInsertion.prototype = {
    dragStart (e) {
    },
    drop (e) {
      if (!prevEl || !e.activeSortable) {
        return false
      }
      const isBlock = _.get(e, 'activeSortable.options.dataSource', false) === 'block'
      const {
        dragEl,
        target
      } = e
      const oldEl = getDragElement(dragEl)
      const newElement = ER.wrapElement(_.cloneDeep(oldEl), inserRowIndex !== '', true, isBlock)
      if (!isBlock) {
        if (oldEl.context) {
          oldEl.context.delete()
          // utils.deepTraversal(oldEl, (node) => {
          //   if (utils.checkIsField(node) && node.type !== 'subform') {
          //     ER.delField(node)
          //   }
          // })
        }
      }
      if (inserRowIndex !== '') {
        let store = []
        if (prevSortable.options.parent.type === 'subform') {
          store = prevSortable.options.parent.list[0]
        } else {
          store = Array.isArray(prevSortable.options.parent) ? prevSortable.options.parent : prevSortable.options.parent.list
        }
        store.splice(inserRowIndex, 0, newElement)
        utils.addContext(store[inserRowIndex], prevSortable.options.parent)
      }
      if (inserColIndex !== '') {
        const {
          el: {
            __draggable_component__: {
              list
            }
          },
          el,
          constructor: {
            utils: sortableUtils
          }
        } = prevSortable
        list.splice(inserColIndex, 0, newElement)
        utils.addContext(newElement, prevSortable.options.parent[sortableUtils.index(prevSortable.el.parentNode)])
      }
      if (inserColIndex !== '' || inserRowIndex !== '') {
        utils.deepTraversal(newElement, (node) => {
          if (utils.checkIsField(node)) {
            ER.addField(node)
          }
        })
        nextTick(() => {
          ER.setSelection(newElement)
        })
      }
      resetStates()
    },
    dragOver (e) {
      // e.originalEvent && e.originalEvent.stopPropagation()
      e.cancel()
      resetStates()
      const {
        activeSortable: {
          constructor: {
            utils: SortableUtils
          },
          options: {
            dataSource
          },
          el: {
            __draggable_component__: {
              list
            }
          }
        },
        activeSortable,
        target,
        originalEvent,
        dragEl,
        sortable: {
          el,
          el: {
            __draggable_component__: {
              list: targetList
            }
          }
        },
        sortable
      } = e
      if (sortable.options.dataSource === 'block') {
        return false
      }
      if (target.dataset.layoutType === 'grid') {
        return false
      }
      const dragNode = getDragElement(dragEl)
      const targetNode = getDragElement(target)
      if ((!utils.checkIsField(dragNode) || dragNode.type === 'subform') && utils.checkIsInSubform(targetNode)) {
        return false
      }
      if (target.dataset.layoutType === 'subform') {
        // console.log(utils)
        if (!utils.checkIsField(dragNode) || dragNode.type === 'subform') {
          return false
        }
      }
      originalEvent.stopPropagation && originalEvent.stopPropagation()
      const direction = ''
      const targetContainer = el.parentNode
      const targetOnlyOne = targetList.length === 1
      let newTarget = SortableUtils.closest(target, this.options.draggable, sortable.el)
      if (dragEl.contains(newTarget)) {
        return false
      }
      if (/^(grid-col|tabs-col|td|collapse-col|root|inline|subform)$/.test(target.dataset.layoutType)) {
        newTarget = target
        const state = (newTarget.__draggable_component__ || newTarget.children[0].__draggable_component__)
        if (!state.list.length) {
          prevEl = target.dataset.layoutType === 'root' ? target : newTarget.__draggable_component__ ? newTarget.children[0] : newTarget.parentNode
          prevSortable = state._sortable
          inserRowIndex = 0
          setBorder(prevEl, 'drag-line-top')
        } else {
          if (/^(root|grid-col)$/.test(target.dataset.layoutType)) {
            const rows = el.children
            prevEl = lastChild(el)
            if (prevEl === dragEl.parentNode.parentNode && list.length === 1) {
              prevEl = ''
              return false
            }
            setBorder(prevEl, 'drag-line-bottom')
            inserRowIndex = rows.length
            prevSortable = state._sortable
          }
          if (target.dataset.layoutType === 'inline') {
            if (disableBothSides(ER)) return false
            const cols = el.children
            prevEl = lastChild(el)
            if (prevEl.contains(dragEl) && list.length === 1) {
              prevEl = ''
              return false
            }
            inserColIndex = cols.length
            prevSortable = state._sortable
            setBorder(prevEl, 'drag-line-right')
          }
        }
      } else {
        setStates(newTarget, e, ER)
      }
    }
  }
  return Object.assign(ControlInsertion, {
    pluginName: 'ControlInsertion',
    initializeByDefault: true
  })



  import { defineComponent, ref, unref, inject, PropType } from 'vue';
import { ElButton } from 'element-plus';
import { Button as VanButton } from 'vant';
import hooks from '@ER/hooks';

export default defineComponent({
  name: 'ErCompleteButton',
  props: {
    handle: Object as PropType<{ validate: () => Promise<void> }>,
    mode: {
      type: String as PropType<'edit' | 'preview'>,
      default: 'edit',
    },
  },
  setup(props) {
    const ER = inject('Everright') as any;
    const ns = hooks.useNamespace('CompleteButton');
    const { state, isPc } = hooks.useTarget();
    const element = ref<string | null>(null);

    const handleClick = async () => {
      if (props.mode === 'preview') return;
      try {
        await Promise.resolve(unref(props.handle)?.validate());
        ER.fireEvent('submit', ER.getData());
      } catch (e) {
        console.error(e);
      }
    };

    const dataset = process.env.NODE_ENV === 'test' ? { 'data-test': 'er-complete-button' } : {};

    return () => (
      <div {...dataset}>
        {isPc.value ? (
          <div style="text-align: center;">
            <ElButton
              onClick={handleClick}
              type="primary"
              style={{ backgroundColor: state.value.config[state.value.platform].completeButton.backgroundColor }}
            >
              <span style={{ color: state.value.config[state.value.platform].completeButton.color }}>
                {state.value.config[state.value.platform].completeButton.text}
              </span>
            </ElButton>
          </div>
        ) : (
          <VanButton
            onClick={handleClick}
            round
            block
            type="primary"
            style={{ backgroundColor: state.value.config[state.value.platform].completeButton.backgroundColor }}
          >
            <span style={{ color: state.value.config[state.value.platform].completeButton.color }}>
              {state.value.config[state.value.platform].completeButton.text}
            </span>
          </VanButton>
        )}
      </div>
    );
  },
});


 // const handleAction = (type) => {
    //   const index = type !== 5 && props.parent.indexOf(props.data);
    //   switch (type) {
    //     case 1:
    //       if (ER.props.delHandle(props.data) === false) return false;
    //       props.data.context.delete();
    //       utils.deepTraversal(props.data, (node) => {
    //         if (utils.checkIsField(node)) {
    //           ER.delField(node);
    //         }
    //       });
    //       if (/^(radio|checkbox|select)$/.test(props.data.type)) {
    //         delete state.data[props.data.options.dataKey];
    //       }
    //       if (props.parent.length > 0) {
    //         if (index === props.parent.length) {
    //           setSelection(props.parent[index - 1]);
    //         } else {
    //           setSelection(props.parent[index]);
    //         }
    //       } else {
    //         setSelection('root');
    //       }
    //       break;
    //     case 2:
    //       if (ER.props.copyHandle(props.data) === false) return false;
    //       props.data.context.copy();
    //       const copyData = props.parent[index + 1];
    //       setSelection(copyData);
    //       utils.deepTraversal(copyData, (node) => {
    //         ER.addFieldData(node, true);
    //         if (utils.checkIsField(node)) {
    //           ER.addField(node);
    //         }
    //       });
    //       break;
    //     case 3:
    //       //@ts-ignore
    //       _.last(props.data.context.columns[0]).context.insert('bottom');
    //       break;
    //     case 4:
    //       //@ts-ignore
    //       _.last(props.data.context.columns)[0].context.insert('right');
    //       break;
    //     case 5:
    //       let parent = props.data.context.parent;
    //       if (/^(inline|tr)$/.test(parent.type)) {
    //         parent = parent.context.parent;
    //       }
    //       setSelection(Array.isArray(parent) ? 'root' : parent);
    //       break;
    //     case 6:
    //       props.data.context.appendCol();
    //       break;
    //   }
    // };